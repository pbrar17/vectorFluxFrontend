<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VectorFlux</title>

  <!-- Libraries -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      background: black;
      color: white;
    }

    nav {
      background: #000;
      padding: 10px;
      text-align: center;
    }

    nav a {
      color: white;
      margin: 0 15px;
      text-decoration: none;
      font-weight: bold;
      font-size: 18px;
      transition: color 0.3s;
    }

    nav a:hover {
      color: #66ccff;
    }

    nav a.active {
      text-decoration: underline;
      color: #66ccff;
    }

    .container {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Mesmerizing gradient title */
    .mesmerizing-title {
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 20px;
      background: linear-gradient(270deg, #ff00cc, #3333ff, #00ffff, #ff00cc);
      background-size: 800% 800%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 15s ease infinite;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    label {
      font-weight: bold;
    }

    input, button, select {
      padding: 10px;
      margin: 5px 10px 15px 0;
      font-size: 16px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      width: 300px;
      max-width: 100%;
      box-sizing: border-box;
    }

    button {
      cursor: pointer;
      border: none;
      background: #007bff;
      transition: background 0.3s;
    }

    button:hover {
      background: #0056b3;
    }

    #plot-wrapper {
      width: 1080px;
      height: 720px;
      overflow: hidden;
      margin: 20px auto;
      border: 1px solid #444;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #plot {
      width: 1080px;
      height: 720px;
    }

    .latex-preview {
      margin-left: 10px;
      font-size: 20px;
      color: #ccc;
      vertical-align: middle;
      display: inline-block;
      min-width: 150px;
      font-family: "Latin Modern Math", "STIX Math", "Cambria Math", serif;
    }

    .range-inputs {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 10px;
    }

    .range-inputs label {
      width: auto;
      margin-right: 5px;
    }

    .range-inputs input {
      width: 120px;
    }
  </style>
</head>
<body>

  <nav>
    <a href="index.html" class="active">VecPlot</a>
    <a href="3dplot.html">3D Plotter</a>
    <a href="vectorfield3dplotter.html">Vector Field Plotter</a>
    <a href="statisticalsolver.html">Statistical Solver</a>
  </nav>

  <div class="container">
    <h1 class="mesmerizing-title">VectorFlux</h1>

    <h2>Interactive Vector Field Streamline Visualizer</h2>

    <div>
      <label for="uInput">u(x, y) = </label>
      <input id="uInput" value="sin(y)" size="40" oninput="updateLatex()" autocomplete="off" spellcheck="false" />
      <span class="latex-preview" id="uLatex"></span>
    </div>

    <div>
      <label for="vInput">v(x, y) = </label>
      <input id="vInput" value="cos(x)" size="40" oninput="updateLatex()" autocomplete="off" spellcheck="false" />
      <span class="latex-preview" id="vLatex"></span>
    </div>

    <div class="range-inputs">
      <div>
        <label for="xMin">xMin</label><br>
        <input id="xMin" type="number" value="-5" step="0.1">
      </div>
      <div>
        <label for="xMax">xMax</label><br>
        <input id="xMax" type="number" value="5" step="0.1">
      </div>
      <div>
        <label for="yMin">yMin</label><br>
        <input id="yMin" type="number" value="-5" step="0.1">
      </div>
      <div>
        <label for="yMax">yMax</label><br>
        <input id="yMax" type="number" value="5" step="0.1">
      </div>
    </div>

    <div>
      <label for="colorScheme">Color Scheme</label><br>
      <select id="colorScheme">
        <option value="Viridis">Viridis</option>
        <option value="Plasma">Plasma</option>
        <option value="Inferno">Inferno</option>
        <option value="Magma">Magma</option>
        <option value="Cool">Cool</option>
        <option value="Warm">Warm</option>
        <option value="Rainbow">Rainbow</option>
        <option value="CubehelixDefault">Cubehelix</option>
      </select>
    </div>

    <div>
      <button id="plotBtn" onclick="plotStreamlines()">Plot Streamlines</button>
      <button id="downloadBtn" onclick="downloadJPEG()">Download JPEG</button>
    </div>

    <div id="plot-wrapper">
      <div id="plot"></div>
    </div>
  </div>

  <script>
    let uCompiled, vCompiled;

    function toLatex(expr) {
      try {
        return math.parse(expr).toTex({ parenthesis: 'keep' });
      } catch {
        return '\\text{Invalid}';
      }
    }

    function updateLatex() {
      const uExpr = document.getElementById('uInput').value.trim();
      const vExpr = document.getElementById('vInput').value.trim();

      document.getElementById('uLatex').innerHTML = `\\( u(x, y) = ${toLatex(uExpr)} \\)`;
      document.getElementById('vLatex').innerHTML = `\\( v(x, y) = ${toLatex(vExpr)} \\)`;
      MathJax.typesetPromise();
    }

    function compileExpressions() {
      try {
        uCompiled = math.compile(document.getElementById('uInput').value);
        vCompiled = math.compile(document.getElementById('vInput').value);
        return true;
      } catch (err) {
        alert("Invalid math expression. Please check your input.");
        return false;
      }
    }

    function evaluate(expr, scope) {
      try {
        return expr.evaluate(scope);
      } catch {
        return 0;
      }
    }

    function generateTraces() {
      if (!compileExpressions()) return null;

      const xMin = parseFloat(document.getElementById("xMin").value);
      const xMax = parseFloat(document.getElementById("xMax").value);
      const yMin = parseFloat(document.getElementById("yMin").value);
      const yMax = parseFloat(document.getElementById("yMax").value);
      const colorName = document.getElementById("colorScheme").value;

      const d3Interpolators = {
        Viridis: d3.interpolateViridis,
        Plasma: d3.interpolatePlasma,
        Inferno: d3.interpolateInferno,
        Magma: d3.interpolateMagma,
        Cool: d3.interpolateCool,
        Warm: d3.interpolateWarm,
        Rainbow: d3.interpolateRainbow,
        CubehelixDefault: d3.interpolateCubehelixDefault,
      };
      const colorInterpolator = d3Interpolators[colorName] || d3.interpolateViridis;

      // Sample points
      const nx = 80;
      const ny = 60;
      const xs = [];
      const ys = [];
      for (let i = 0; i < nx; i++) {
        xs.push(xMin + (xMax - xMin) * i / (nx - 1));
      }
      for (let j = 0; j < ny; j++) {
        ys.push(yMin + (yMax - yMin) * j / (ny - 1));
      }

      // Evaluate vector magnitudes for color mapping
      let magMin = Infinity;
      let magMax = -Infinity;
      const mags = [];
      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const scope = { x: xs[i], y: ys[j] };
          const uVal = evaluate(uCompiled, scope);
          const vVal = evaluate(vCompiled, scope);
          const mag = Math.sqrt(uVal * uVal + vVal * vVal);
          mags.push(mag);
          if (mag < magMin) magMin = mag;
          if (mag > magMax) magMax = mag;
        }
      }
      if (magMin === magMax) {
        magMin = 0;
      }

      // Generate streamline traces: here we do simple quiver (arrows) for demo
      // For actual streamlines you'd implement ODE integration or use a library
      // For simplicity, plot arrows at a grid of points

      const arrowLength = (xMax - xMin) / nx * 0.8;

      const xArr = [];
      const yArr = [];
      const uArr = [];
      const vArr = [];
      const colors = [];

      for (let j = 0; j < ny; j += 4) { // sparser for clarity
        for (let i = 0; i < nx; i += 4) {
          const scope = { x: xs[i], y: ys[j] };
          const uVal = evaluate(uCompiled, scope);
          const vVal = evaluate(vCompiled, scope);
          const mag = Math.sqrt(uVal * uVal + vVal * vVal);
          if (mag === 0) continue;

          xArr.push(xs[i]);
          yArr.push(ys[j]);
          uArr.push(uVal / mag * arrowLength);
          vArr.push(vVal / mag * arrowLength);
          const c = colorInterpolator((mag - magMin) / (magMax - magMin));
          colors.push(c);
        }
      }

      // Construct arrow traces using Plotly's scatter with line segments
      // Each arrow is a line + triangle at end - Plotly does not support arrow markers natively
      // For demo, use lines only

      const arrowTraces = [];
      for (let k = 0; k < xArr.length; k++) {
        arrowTraces.push({
          type: 'scatter',
          mode: 'lines',
          x: [xArr[k], xArr[k] + uArr[k]],
          y: [yArr[k], yArr[k] + vArr[k]],
          line: {
            color: colors[k],
            width: 2
          },
          hoverinfo: 'none',
          showlegend: false
        });
      }

      return arrowTraces;
    }

    function plotStreamlines() {
      const traces = generateTraces();
      if (!traces) return;

      const xMin = parseFloat(document.getElementById("xMin").value);
      const xMax = parseFloat(document.getElementById("xMax").value);
      const yMin = parseFloat(document.getElementById("yMin").value);
      const yMax = parseFloat(document.getElementById("yMax").value);

      const layout = {
        autosize: false,
        width: 1080,
        height: 720,
        margin: { l: 40, r: 40, b: 40, t: 40 },
        paper_bgcolor: 'black',
        plot_bgcolor: 'black',
        xaxis: {
          range: [xMin, xMax],
          zeroline: false,
          showgrid: false,
          showticklabels: false,
          ticks: '',
          showline: false,
          scaleanchor: 'y',
          scaleratio: 1,
        },
        yaxis: {
          range: [yMin, yMax],
          zeroline: false,
          showgrid: false,
          showticklabels: false,
          ticks: '',
          showline: false,
        },
        hovermode: false,
      };

      Plotly.newPlot('plot', traces, layout, { displayModeBar: false, staticPlot: false });
    }

    async function downloadJPEG() {
      const xMin = parseFloat(document.getElementById("xMin").value);
      const xMax = parseFloat(document.getElementById("xMax").value);
      const yMin = parseFloat(document.getElementById("yMin").value);
      const yMax = parseFloat(document.getElementById("yMax").value);

      const layout = {
        autosize: false,
        width: 1080,
        height: 720,
        margin: { l: 40, r: 40, b: 40, t: 40 },
        paper_bgcolor: 'black',
        plot_bgcolor: 'black',
        xaxis: {
          range: [xMin, xMax],
          zeroline: false,
          showgrid: false,
          showticklabels: false,
          ticks: '',
          showline: false,
          scaleanchor: 'y',
          scaleratio: 1,
        },
        yaxis: {
          range: [yMin, yMax],
          zeroline: false,
          showgrid: false,
          showticklabels: false,
          ticks: '',
          showline: false,
        },
        hovermode: false,
      };

      const traces = generateTraces();
      if (!traces) return;

      try {
        const imgData = await Plotly.toImage({
          data: traces,
          layout: layout,
          format: 'jpeg',
          width: 1080,
          height: 720,
          scale: 1,
        });

        const link = document.createElement('a');
        link.href = imgData;
        link.download = 'vectorflux-streamlines.jpg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } catch (err) {
        alert("Failed to generate image. Please try again.");
        console.error(err);
      }
    }

    // Initial latex rendering
    updateLatex();

    // Initial plot on page load
    window.onload = plotStreamlines;

  </script>

</body>
</html>
